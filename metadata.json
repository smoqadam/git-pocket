{
  "2025-06-29-1618-solvingpassportapplicationwithhaskell": {
    "title": "Solving `Passport Application` with Haskell",
    "url": "https://jameshaydon.github.io/passport/",
    "url_hash": "60017c5a",
    "date": "2025-06-29T16:18:09.841122",
    "authors": [],
    "content_html": "<html><body><div><div itemprop=\"articleBody\">\n<p>(Comments on <a href=\"https://news.ycombinator.com/item?id=44408872\">HackerNews</a> and <a href=\"https://www.reddit.com/r/haskell/comments/1lmzvus/solving_uk_passport_application_with_haskell/\">Reddit</a>)</p>\n<p>There's a trend at the moment of <a href=\"https://news.ycombinator.com/item?id=44363696\">solving</a> online <a href=\"https://news.ycombinator.com/item?id=44273489\">games</a> with <a href=\"https://news.ycombinator.com/item?id=44259476\">programming</a>, let's do one from the UK called <em>Passport Application</em>, which is developed by <a href=\"https://www.gov.uk/government/organisations/hm-passport-office\">\"His Majesty's Passport Office\"</a> or HMPO. It's a cultural phenomenon in the UK: despite being quite expensive (about £100 just to start) for the standard online version (a masterpiece of minimalist design, entirely text-based), most British play the game, and do so every 10 years or so.</p>\n<p>It's an adventure puzzle document collection game. The premise is to collect enough artefacts, scattered throughout various bureaucratic institutions, until you can prove the statement \"Applicant is British\" according to an extremely complex set of rules, written in arcane language, in various texts called \"acts of parliament\". The prize for winning is a little booklet with a date inside that indicates when you can play again.</p>\n<span id=\"continue-reading\"></span>\n<p>Hardcore players opt for an entirely paper-based version that relies entirely on postal mail. The puzzle-sheets for that look like this:</p>\n<img alt=\"UK Passport Application paper form\" src=\"https://jameshaydon.github.io/passport/paper-form.png\"/>\n<p>There are various instructions for what collectibles need to be gathered, presented in game instruction manuals such as:</p>\n<p><img alt=\"Documents Table\" src=\"https://jameshaydon.github.io/passport/docs-table.jpg\" title=\"Documents Table\"/></p>\n<p>The game starts easy enough, you just need to enter basic facts about the applicant, and take a photo of them. But things get tougher from there, with various side-quests, all designed to be fun:</p>\n<ul>\n<li>HMPO sometimes decides to send you on an \"identity confirmation\" side quest. This involves finding someone whose job/status is one of a finite list, things like \"accountant\" or \"civil servant\", but they also have some fun ones like \"chiropodist\", \"funeral director\" and \"airline pilot\". Once you've managed to track down such a person, preferably one who knows you, you must socially engineer them into filling in some webforms.</li>\n<li>The main mechanic of the game involves sending in \"original\" documents. Documents that are not in english need to be paired with an \"officially certified translation\", which triggered some cool side-quests in my case like \"how to get a certified translation of a French marriage certificate, which is in my possession in Japan, and have both sent to HMPO by mail\".</li>\n<li>Some documents relate to family members, and so you need to start getting the whole family involved in a co-op mode.</li>\n<li>And of course the bureaucratic institutions you must request some documents from have their own arcane gameplay.</li>\n</ul>\n<p>All this keeps the game interesting and fun, taking weeks and sometimes months to complete. Non-British people aren't <em>really</em> supposed to play, but seeing as proving Britishness is the whole object of the game, it's actually open to anyone! I thoroughly encourage you to give it a go.</p>\n<p>So this time I was playing on behalf of my daughter, because I'd already completed the game recently, and besides she's too young to play on her own. I played online and chose the \"first child passport born abroad\" difficulty level, so expected it to be quite challenging from the outset. After a round of waiting, the first round of document requests came through.\nQuite a lot of documents, most of which seemed quite unrelated to the main objective, but that's the game. I started collecting them but some were quite difficult to obtain so I decided to use the chat feature. You see your game is handled by a person called an \"examiner\", they are the ones who send you on document gathering quests, according to their interpretation of the rules. To add an extra layer of difficulty, you can't directly communicate with this person, you can only talk to \"advice agents\" using a chat or telephone service. These agents offer advice on side-quests, but nothing they say is official. They can pass along questions to the examiner, but that triggers a few days of waiting time, sometimes up to 10 days in my case, a tactic used to build suspense.</p>\n<p>Quite quickly the chat service told me that 50% of the initial documents requested were unnecessary; it was all just a misdirection! So another round of waiting, and then more document requests. You get document requests via emails like this:</p>\n<img alt=\"Document Request\" src=\"https://jameshaydon.github.io/passport/doc-request-email.png\"/>\n<p>The document requests are paired with some cryptic explanations that are somewhat helpful but still vague enough to keep the game interesting. Why don't I have parental responsibility for <code>__APPLICANT_NAME__</code>? One of the listed conditions is \"named on the child's birth certificate\", which I am, and was already sent to them, along with the Japanese→English translation. Maybe they also need proof of the first condition, despite the second, and despite this document not having been requested earlier in the process. In any case I can't satisfy the third. Or maybe some automated system has messed up; the broken HTML templating indicates that maybe <code>APPLICANT_NAME == NULL</code> in some database, who knows.</p>\n<p>Another round of document requests, one for a document that doesn't exist, another round of helpline. More explorations of conversation trees with NPCs, an alternative path to the goal is found, more documents. This culminated in a rare relic request:</p>\n<blockquote>\n<p>Applicant's Paternal great-grandfather's birth certificate and marriage certificate</p>\n</blockquote>\n<p>One of these documents is almost 100 years old! Of course <code>applicant's Paternal great grandfather</code> is ambiguous, since most people have 2 of them, but this is standard misdirection at this point and all part of the fun. After decrypting this to <code>applicant's father's father's father's birth certificate</code> I started to wonder why such a distant document would be requested. Engaging the advice agents didn't help much, one launched into explanations as to why\n$$\\text{birthCirt}(\\text{father}^2(\\text{applicant}))$$ was needed even though this document was already in their possession, and I was asking about\n$$\\text{birthCirt}(\\text{father}^3(\\text{applicant}))$$, then admitted they couldn't quite say why the was needed.</p>\n<p>So what's going on here? It's important to understand the sort of logic used by HMPO in the <em>Passport Application</em> game. It's called <strong>Bureaucratic Logic</strong>, it derives from <a href=\"https://en.wikipedia.org/wiki/Constructive_logic\">Constructive Logic</a>, in that one cannot just make valid arguments, that would be too easy, one has to construct proofs of a particular nature to back them up. Constructive logic has witnesses, Bureaucratic logic has original documents.</p>\n<p>For example, like constructive logic, HMPO doesn't allow you to use excluded middle: $P \\lor \\lnot P$ ($P$ or not $P$) is not in general valid. The gameplay is greatly influenced by answers to questions such as \"was applicant's father's father born in the UK or not born in the UK?\" But you can't just say \"yes one of those is true\" and then provide documents for both resulting scenarios. That would be using excluded middle. You <em>must</em> commit to one alternative <em>and</em> provide a document for that. This is were it's important to remember that it's not about actually demonstrating citizenship, for which excluded middle would be a perfectly valid argument, <em>Passport Application</em> is about having fun gathering documents. Don't question the rules too much or you'll stop having fun.</p>\n<p>The second piece of the puzzle is in the guidance that accompanies the document requests:</p>\n<blockquote>\n<p>British passports are issued to those who have a claim to British nationality under the British Nationality Act 1981. This is decided mainly by a person’s place and date of birth and their parents’ places and dates of birth. A person born outside of the UK after 31 December 1982 is normally a British citizen only if, at the time of their birth one parent is a British citizen otherwise than by descent, such as through birth in the UK or registration or naturalisation as a British citizen.</p>\n</blockquote>\n<p>Note that the Britishness of a person can be dependent on the Britishness of their parents. The final piece of the puzzle is that HMPO doesn't trust its own passports records to prove Britishness. This is the mechanic which, in some cases, kicks off <em>recursive</em> document requests up the family tree, until a base case is reached. What are the base cases? A base case is an ancestor whose Britishness <em>does not</em> depend on a parent, e.g. someone who was naturalised, or born in the UK before 1983 (which makes one unconditionally british regardless of parents). That's right, further into the future we get from 1983, the taller these call-stacks can get. Fun!</p>\n<p>This is how the request chain pertaining to this document played out in my case (in parallel to other requests), quotes are from HMPO emails:</p>\n<p>Note that the recursion is playing out via email.</p>\n<p>At this point I did what any sane person would do, I reached for a logic programming language and decided to encode the rules in the hope of figuring out what was going on. Is it possible to write some code which could have produced the full list of required documents upfront, with no confusion, and perfect explanations? Of course this would ruin all the fun of the game, which is why HMPO doesn't do it, but let's forge ahead.</p>\n<h2 id=\"haskell-code\">Haskell code</h2>\n<p>(Full code is on <a href=\"https://github.com/jameshaydon/uk-passport/blob/main/src/Lib.hs\">GitHub</a>.)</p>\n<p>At first I started encoding the rules in Prolog, but switched to Haskell's <code>LogicT</code> monad after a while. The basic goal here is to produce the full list of documents required for the application. But this isn't quite right: because there are several ways one can claim Britishness, there are several sets of documents that can work, and you only need one of them. So really one is looking for a function that returns <code>Set (Set Document)</code>, where</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>data </span><span>Parent </span><span>= </span><span>Mother </span><span>| </span><span>Father\n</span><span>  </span><span>deriving</span><span> (</span><span>Show</span><span>, </span><span>Eq</span><span>, </span><span>Ord</span><span>)\n</span><span>\n</span><span>data </span><span>Person </span><span>= </span><span>Applicant </span><span>| </span><span>Parent Parent Person\n</span><span>  </span><span>deriving</span><span> (</span><span>Show</span><span>, </span><span>Eq</span><span>, </span><span>Ord</span><span>)\n</span><span>  \n</span><span>data </span><span>Document\n</span><span>  </span><span>= </span><span>BirthCertificate Person\n</span><span>  </span><span>| </span><span>MarriageCertificate Person Person\n</span><span>  </span><span>| </span><span>NaturalizationCertificate Person\n</span><span>  </span><span>| </span><span>Passport Person\n</span><span>  </span><span>-- more documents\n</span><span>  </span><span>deriving</span><span> (</span><span>Show</span><span>, </span><span>Eq</span><span>, </span><span>Ord</span><span>)\n</span></code></pre>\n<p>But this is also unsatisfying, because you want to know <em>why</em> a certain document set is enough. So this is really a proof-search problem, and we proceed in two stages:</p>\n<ul>\n<li>we use <code>LogicT</code> to enumerate all the <code>Proof</code>s of Britishness for the applicant, given some information about them, and</li>\n<li>for each <code>Proof</code> we compute the <code>Set (Set Document)</code> that is needed to satisfy that proof.</li>\n</ul>\n<p>This two-staged approach is what made me switch to Haskell, though I'm sure someone more experienced with Prolog would have made it work.</p>\n<p>So we define a simple proof type:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>data </span><span>Proof\n</span><span>  </span><span>= </span><span>-- Deriving britishness via a parent, and their proof of britishness\n</span><span>    </span><span>ViaParent Person Proof\n</span><span>  </span><span>| </span><span>-- Britishness via two claims.\n</span><span>    </span><span>And Proof Proof\n</span><span>  </span><span>| </span><span>-- Foundational evidence.\n</span><span>    </span><span>Evidence Predicate\n</span><span>  </span><span>deriving</span><span> (</span><span>Show</span><span>)\n</span></code></pre>\n<p>This type could be made much more complex, detailing each rule that was used, but this simpler type was at least enough for my purposes. One feature I wanted was that one would not need to provide all the information upfront, instead questions would be asked interactively, and only if needed. Furthermore, previous facts should be retained and used for all branches, backtracking, etc. So we need <code>IO</code> and <code>State</code>, and we want the state to be global across all branches:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>data </span><span>Knowledge </span><span>= </span><span>SureYes </span><span>| </span><span>SureNo </span><span>| </span><span>Unsure\n</span><span>  </span><span>deriving</span><span> (</span><span>Eq</span><span>)\n</span><span>\n</span><span>type </span><span>Claims </span><span>= </span><span>Map Predicate Knowledge\n</span><span>\n</span><span>type </span><span>M</span><span> a </span><span>= </span><span>StateT Claims</span><span> (</span><span>LogicT IO</span><span>) a\n</span></code></pre>\n<p>Here <code>Predicate</code>s are the sorts of things that are true of a person and affect how the rules of the game play out:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>data </span><span>Predicate\n</span><span>  </span><span>= </span><span>IsBritish Person\n</span><span>  </span><span>| </span><span>Settled Person\n</span><span>  </span><span>| </span><span>BornBefore Int Person\n</span><span>  </span><span>| </span><span>BornInUK Person\n</span><span>  </span><span>| </span><span>BornAfter Int Person\n</span><span>  </span><span>| </span><span>Naturalized Person\n</span><span>  </span><span>| </span><span>Years3LivingInUK Person\n</span><span>  </span><span>| </span><span>IsBritOtbd Person\n</span><span>  </span><span>| </span><span>Married Person Person\n</span><span>  </span><span>deriving</span><span> (</span><span>Show</span><span>, </span><span>Eq</span><span>, </span><span>Ord</span><span>)\n</span></code></pre>\n<p>Here is then the root function for Britishness:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>-- | Is a person british?\n</span><span>brit </span><span>:: Person -&gt; M Proof\n</span><span>brit p </span><span>=\n</span><span>  </span><span>do\n</span><span>    check (</span><span>IsBritish</span><span> p)\n</span><span>    byBirth </span><span>&lt;|&gt;</span><span> naturalised\n</span><span>  </span><span>where\n</span><span>    byBirth </span><span>=\n</span><span>      ifThenElse\n</span><span>        (evidence (</span><span>BornInUK</span><span> p))\n</span><span>        (britBornInUk p)\n</span><span>        (britBornAbroad p)\n</span><span>    naturalised </span><span>=</span><span> evidence (</span><span>Naturalised</span><span> p)\n</span></code></pre>\n<p>The <code>check</code> function here interacts with the user, to avoid launching into an investigation if the user knows that person is not british:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>-- | Ask about a predicate, failing if the answer is a sure no.\n</span><span>check </span><span>:: Predicate -&gt; M </span><span>()\n</span><span>check q </span><span>= </span><span>do\n</span><span>  answer </span><span>&lt;-</span><span> question q\n</span><span>  guard (answer </span><span>/= </span><span>SureNo</span><span>)\n</span></code></pre>\n<p>A person is <code>brit</code> either <code>byBirth</code> or <code>naturalised</code>. Naturalisation is the simplest, as a single certificate is then the sole document needed. Britishness by birth forks mainly on whether or not the person was born in the UK, and we go to sub-routines:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>-- | UK-born citizenship (pre-1983 or via parent)\n</span><span>britBornInUk </span><span>:: Person -&gt; M Proof\n</span><span>britBornInUk p </span><span>=</span><span> evidence (</span><span>BornBefore 1983</span><span> p) </span><span>`</span><span>orElse</span><span>`</span><span> britBornInUkViaParent p\n</span><span>\n</span><span>-- | UK-born citizenship via parent (used for post-1983 births)\n</span><span>britBornInUkViaParent </span><span>:: Person -&gt; M Proof\n</span><span>britBornInUkViaParent p </span><span>=</span><span> viaParent p (</span><span>\\</span><span>parent </span><span>-&gt;</span><span> brit parent </span><span>`</span><span>orElse</span><span>`</span><span> settled parent)\n</span></code></pre>\n<p>People born in the UK before <code>1983</code> are a base case, they are unconditionally British. Otherwise they acquire it via at least one their parents, who must be either British themselves or \"settled\" at time of birth. The <code>orElse</code> function here is similar to <code>&lt;|&gt;</code>, but doesn't include proofs from the second branch at all if the first is successful (<code>&lt;|&gt;</code> always accumulates proofs from both branches). E.g. if <code>brit parent</code> is true then <code>settled parent</code> doesn't apply: there is no notion of \"settled in the UK\" for British people.</p>\n<p>When not born in the UK things are more complex:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>-- | British citizenship for those born abroad\n</span><span>britBornAbroad </span><span>:: Person -&gt; M Proof\n</span><span>britBornAbroad p </span><span>=\n</span><span>  viaParent p </span><span>$ \\</span><span>parent </span><span>-&gt;\n</span><span>    britOtbd parent </span><span>`</span><span>orElse</span><span>`</span><span> (brit parent </span><span>`</span><span>and</span><span>`</span><span> evidence (</span><span>Years3LivingInUK</span><span> parent))\n</span><span>\n</span><span>-- | British otherwise than by descent (BOTD)\n</span><span>britOtbd </span><span>:: Person -&gt; M Proof\n</span><span>britOtbd p </span><span>= </span><span>do\n</span><span>  check (</span><span>IsBritOtbd</span><span> p)\n</span><span>  evidence (</span><span>Naturalised</span><span> p) </span><span>`</span><span>orElse</span><span>`</span><span> britOtbdUkBorn </span><span>`</span><span>orElse</span><span>`</span><span> bornCrownService p\n</span><span>  </span><span>where\n</span><span>    britOtbdUkBorn </span><span>=</span><span> evidence (</span><span>BornInUK</span><span> p) </span><span>`</span><span>and</span><span>`</span><span> britBornInUk p\n</span><span>\n</span><span>bornCrownService </span><span>:: Person -&gt; M Proof\n</span><span>bornCrownService p </span><span>=</span><span> viaParent p </span><span>$ \\</span><span>parent </span><span>-&gt; </span><span>do\n</span><span>  check (</span><span>CrownService</span><span> parent)\n</span><span>  brit parent </span><span>`</span><span>and</span><span>`</span><span> evidence (</span><span>CrownService</span><span> parent)\n</span></code></pre>\n<p>When not born in the UK, you get citizenship from your parents in the usual way only if there is evidence of 3 years of consecutive living in the UK, or if born from a person that is <em>British otherwise than by descent</em> (BOTBD). This is a person with \"super Britishness\", they can confer citizenship to their children unconditionally (well, apart from having to play hard games of <code>Passport Application</code>). The basic idea is that someone is BOTBD if they didn't become British purely via a parent. E.g. they were naturalised, or born in the UK, etc. There are <em>many</em> edge-cases in the rules, and I've only coded those that are most relevant to my case. One of them is <code>bornCrownService</code>, this says that one is still BOTBD if born abroad <em>because a parent was working in \"Crown Service\"</em>, e.g. in an embassy. This happens to be the case of $\\text{father}^3(\\text{applicant})$ during the birth of $\\text{father}^2(\\text{applicant})$, but is this relevant? We'll have to wait till we've coded enough to run this program.</p>\n<p>A lot of these functions rely on a higher order function <code>viaParent</code>, which mediates how citizenship is passed down to children:</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>viaParent </span><span>:: Person -&gt;</span><span> (</span><span>Person -&gt; M Proof</span><span>) </span><span>-&gt; M Proof\n</span><span>viaParent p cond </span><span>=</span><span> viaMother </span><span>&lt;|&gt;</span><span> viaFather\n</span><span>  </span><span>where\n</span><span>    via parent </span><span>= </span><span>ViaParent</span><span> (</span><span>Parent</span><span> parent p) </span><span>&lt;$&gt;</span><span> cond (</span><span>Parent</span><span> parent p)\n</span><span>    viaMother </span><span>=</span><span> via </span><span>Mother\n</span><span>    viaFather </span><span>=\n</span><span>      ifThenElse\n</span><span>        (evidence (</span><span>BornAfter 2006</span><span> p))\n</span><span>        (via </span><span>Father</span><span>)\n</span><span>        (married (</span><span>Parent Father</span><span> p) (</span><span>Parent Mother</span><span> p) </span><span>`</span><span>and</span><span>`</span><span> via </span><span>Father</span><span>)\n</span></code></pre>\n<p>This takes a person, and a <code>cond</code>ition for a parent, and produces a proof of Britishness for <code>p</code> as long as <code>cond</code> can be proved for one of <code>p</code>'s parents. There is an extra complication here relating to laws surrounding \"illegitimate\" children born before 2006, so an extra check for marriage is required in some cases. There are ways around this not codified here (\"registration\"). There are other sexist clauses too, about only fathers passing on Britishness in some cases, that I also haven't codified here. It's interesting that even though some of these laws no longer apply, they apply <em>historically</em> when trying to work out if an ancestor was british. That's right, to play <code>Passport Application</code> you need to consult laws from many different times!</p>\n<p>To run the code we <code>observeAllT (evalStateT m Map.empty)</code>, the <code>Map.empty</code> indicating we start with no knowledge. Once a proof has been found we use <code>docs :: Proof -&gt; Logic (Set Document)</code> to produce the needed documents for <em>that path</em> to citizenship. This will mostly list out documents for foundational evidence, and e.g. make sure that when <code>ViaParent</code> is used, a birth certificate linking parent and child is produced.</p>\n<p>Let's run it!</p>\n<pre><code><span>ghci&gt; run (brit Applicant)\n</span><span>? : Applicant is british\n</span><span>y\n</span><span>? : Applicant was born in UK\n</span><span>n\n</span><span>? : Applicant's Mother is british otherwise than by descent\n</span><span>n\n</span><span>? : Applicant was born after 2006\n</span><span>y\n</span><span>? : Applicant's Father is british otherwise than by descent\n</span><span>y\n</span><span>? : Applicant's Father was born in UK\n</span><span>y\n</span><span>? : Applicant's Father was born before 1983\n</span><span>n\n</span><span>? : Applicant's Father's Mother is british\n</span><span>n\n</span><span>? : Applicant's Father's Mother was settled at time of birth\n</span><span>y\n</span><span>? : Applicant's Father was born after 2006\n</span><span>n\n</span><span>? : Applicant's Father's Father was married to Applicant's Father's Mother at time of birth\n</span><span>y\n</span><span>? : Applicant's Father's Father is british\n</span><span>...\n</span></code></pre>\n<p>This goes on for quite some questions, 37 in my case. You can answer question like <code>Applicant's Mother is british otherwise than by descent</code> with \"dk\" (don't know), and in this case it will explore the tree for you, the main use is <em>not</em> exploring this branch if you do know it is futile.</p>\n<p>Once all the citizenship proofs are produced, they are printed and possible document sets are produced:</p>\n<pre><code><span>Applicant has 3 proof(s) of britishness:\n</span><span>\n</span><span>-----------\n</span><span>Proof 1:\n</span><span>\n</span><span>• Applicant was born after 2006\n</span><span>• Via Applicant's Father's britishness:\n</span><span>    • Applicant's Father was born in UK\n</span><span>    • Via Applicant's Father's Mother's britishness:\n</span><span>        Applicant's Father's Mother was settled at time of birth\n</span><span>\n</span><span>Possible doc sets:\n</span><span>• - Birth certificate for Applicant,\n</span><span>  - Birth certificate for Applicant's Father,\n</span><span>  - Settled status document for Applicant's Father's Mother\n</span><span>\n</span><span>-----------\n</span><span>Proof 2:\n</span><span>\n</span><span>• Applicant was born after 2006\n</span><span>• Via Applicant's Father's britishness:\n</span><span>    • Applicant's Father was born in UK\n</span><span>    • • Applicant's Father's Father was married to Applicant's Father's Mother at time of birth\n</span><span>      • Via Applicant's Father's Father's britishness:\n</span><span>          Via Applicant's Father's Father's Mother's britishness:\n</span><span>            • Applicant's Father's Father's Mother was born in UK\n</span><span>            • Applicant's Father's Father's Mother was born before 1983\n</span><span>\n</span><span>Possible doc sets:\n</span><span>• - Birth certificate for Applicant,\n</span><span>  - Birth certificate for Applicant's Father's Father's Mother,\n</span><span>  - Birth certificate for Applicant's Father,\n</span><span>  - Birth certificate for Applicant's Father's Father,\n</span><span>  - Marriage certificate for Applicant's Father's Father and Applicant's Father's Mother\n</span><span>\n</span><span>-----------\n</span><span>Proof 3:\n</span><span>\n</span><span>• Applicant was born after 2006\n</span><span>• Via Applicant's Father's britishness:\n</span><span>    • Applicant's Father was born in UK\n</span><span>    • • Applicant's Father's Father was married to Applicant's Father's Mother at time of birth\n</span><span>      • Via Applicant's Father's Father's britishness:\n</span><span>          • Applicant's Father's Father's Father was married to Applicant's Father's Father's Mother at time of birth\n</span><span>          • Via Applicant's Father's Father's Father's britishness:\n</span><span>              • Applicant's Father's Father's Father was born in UK\n</span><span>              • Applicant's Father's Father's Father was born before 1983\n</span><span>\n</span><span>Possible doc sets:\n</span><span>• - Birth certificate for Applicant,\n</span><span>  - Birth certificate for Applicant's Father,\n</span><span>  - Birth certificate for Applicant's Father's Father,\n</span><span>  - Birth certificate for Applicant's Father's Father's Father,\n</span><span>  - Marriage certificate for Applicant's Father's Father and Applicant's Father's Mother,\n</span><span>  - Marriage certificate for Applicant's Father's Father's Father and Applicant's Father's Father's Mother\n</span></code></pre>\n<p>And there it is, in <code>Proof 3</code>:</p>\n<pre><code><span>Birth certificate for Applicant's Father's Father's Father\n</span></code></pre>\n<p>The \"Crown Service\" status of $\\text{father}^3(\\text{applicant})$ caused quite some confusion in my case, because $\\text{father}^2(\\text{applicant})$ was indeed born abroad, causing some amount of recursion. But hilariously the crown service of $\\text{father}^3(\\text{applicant})$ turns out to be totally irrelevant, indeed the BOTBD status of $\\text{father}^1(\\text{applicant})$ is already derived from being born in the UK and simple Britishness of $\\text{father}^2(\\text{applicant})$. But this simple Britishness still needs to be established, so the recursion to $\\text{father}^2(\\text{applicant})$ still occurs. And the marriage certificate is needed too, for the \"legitimacy\" of $\\text{father}^2(\\text{applicant})$; the marital status of my deceased grandparents has suddenly become one of my most important concerns.</p>\n<p>Interestingly, the proof that HMPO has selected for my case is the longest and most complex of the 3, I assume that when there are several choices they send the player down the most complex one, for extra fun. Indeed <code>Proof 1</code> is quite simple, it requires only proving a settled status of one ancestor <em>and that's it</em>. Citizenship via <em>non-british</em> settled ancestors can be much simpler, because these cases are non-recursive. <code>Proof 2</code> is also slightly more optimized, because it relies on <code>Birth certificate for Applicant's Father's Father's Mother</code>, which therefore bypasses the need for a marriage certificate, needed in <code>Proof 3</code> to prove \"legitimacy\" of <code>Applicant's Father's Father</code>.</p>\n<p>Proofs relying on Britishness bottom out when reaching a person born before 1983 in the UK, the further we get from this date, the longer the proofs become. This applies, at least in theory, <em>even when everyone involved is born in the UK</em>. In practice this doesn't happen because HMPO doesn't actually apply the laws as written in the act, they have their own guidance documents, and act using the principle of <a href=\"https://www.gov.uk/government/publications/balance-of-probabilities/balance-of-probabilities-accessible\">balance of probabilities</a>, and there seems to be guidance indicating that for standard applications from the UK for people born in the UK, one can use \"Main Index\" (their internal passport database). So you have to play on \"hard mode\", e.g. birth abroad, which triggers some global \"extra scrutiny\" flag, which prevents the use of \"Main Index\" in <em>all recursive calls</em>.</p>\n<ul>\n<li>\n<p>There are several places where I have used <code>orElse</code>, but <code>&lt;|&gt;</code> could be used instead. As mentioned above, <code>&lt;|&gt;</code> will explore both branches, but <code>orElse</code> only explores the second branch if the first completely fails. In the case of</p>\n<pre class=\"language-haskell\" data-lang=\"haskell\"><code class=\"language-haskell\" data-lang=\"haskell\"><span>brit parent </span><span>`</span><span>orElse</span><span>`</span><span> settled parent\n</span></code></pre>\n<p>this is completely valid, but in some of the other situations it's not so simple. This one for example:</p>\n<pre><code><span>britOtbd parent `orElse` and (brit parent) (evidence (Years3LivingInUK parent))\n</span></code></pre>\n<p>really could be an <code>&lt;|&gt;</code>, and in my case it makes for much more proofs of citizenship. But it involves an extra level of bureaucratic process (\"Registration\"), so it seems HMPO will try to exhaust <code>britOtbd parent</code> before trying the second branch.</p>\n</li>\n<li>\n<p>Some things are not tracked carefully enough, for example there are something which have to be true <em>at</em> certain times, e.g. some people need to be married or settled specifically at the time some other person was born. But this wouldn't be hard to do.</p>\n</li>\n<li>\n<p>The above is mostly just an encoding of the part of the law that was applicable to my case, or that I found interesting, the full thing would need much more code, and lots and lots of edge-cases.</p>\n</li>\n<li>\n<p><em>Should</em> such things be automated more? It seems clear that this would have been useful in my case, if I was given access to such software I could have produced the correct set of documents much faster, and understood why things got complex. I think institutions like HMPO shy away from such software because UK nationality law is extremely nuanced, so if a computer program gives a false positive in some case it might cause a lot of trouble, with people complaining they aren't being given a passport even though \"computer says yes\". And full automation, replacing human expertise, can be even worse, with people being denied citizenship because \"computer says no\".</p>\n<p><img alt=\"Computer says no\" src=\"https://jameshaydon.github.io/passport/computer-says-no.jpg\" title=\"No\"/></p>\n</li>\n</ul>\n<hr/>\n<p>I've still not finished my current game of PassportApplication, I'm trying to get through proofs 2 and 3 simultaneously, and failing that will try proof 1.</p>\n</div>\n</div></body></html>",
    "summary": "Solving `Passport Application` with Haskell"
  }
}
