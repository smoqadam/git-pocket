<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How to write and package desktop apps with Tauri + Vue + Python</title>
    <meta name="author" content="Senhaji Rhazi Hamza">
    <link rel="stylesheet" href="../templates/assets/article-styles.css">
</head>
<body>
    <div class="nav">
        <a href="../index.html">← Back to Index</a>
    </div>
    <div class="article-header">
        <h1>How to write and package desktop apps with Tauri + Vue + Python</h1>
        <div class="metadata">
            <div class="metadata-item">📅 2025-04-28</div>
            <div class="metadata-item">✍️ Senhaji Rhazi Hamza</div>
            <div class="metadata-item">🔗 <a href="https://hamza-senhajirhazi.medium.com/how-to-write-and-package-desktop-apps-with-tauri-vue-python-ecc08e1e9f2a" class="source" target="_blank">Original Source</a></div>
        </div>
    </div>
    <div class="content">
        First of all, why desktop app with web technologies ?</p><p></p><p>Historical an current context :</p><p></p><p>As hinted in the introduction, writing desktop apps adds a layer of complexity to software editors, due to the fact that they don’t control the environment their apps are running on.</p><p></p><p>Due to this complexity Java got extremely popular in the 90s and early 2000s because with the JVM (java virtual machine) the leitmotiv “write once, run anywhere” was somehow achieved. JVM gives you the guarantee (at a certain extent) that you don’t have to care about your user’s environment, since your code will compile to java byte code, and once compiled to byte code, the JVM take it from there and runs it on the system it is installed on. Thus, back then, many applications got built using a popular java library Swing / AWT.</p><p></p><p>JVM was really a big step in desktop applications, still one last friction remaining for businesses, they were requiring both desktop-grade performance and web-like reach, thus, the definition of run everywhere got extended from desktop only to desktop and web, hence browsers. This was something, that Swing couldn’t do, and the set of skills to rewrite a comparable Swing UI app to its web version was completely different, so unlikely to be the same team, the same constraints etc…</p><p></p><p>This additional extension of the definition of everywhere emphasized the need to have an unified way to write apps for both worlds, thus using web technologies to write desktop apps was a good approach, that way the same team who wrote the web version could write/adapt the desktop version and vice versa, which makes total sens from business standpoint, this is what made Electron very popular and gave birth to apps like Atom or Vscode</p><p></p><p>Why Tauri then ?</p><p></p><p>Electron is great but :</p><p></p><p>While Electron revolutionized cross-platform desktop development by allowing developers to use familiar web technologies (HTML, CSS, JavaScript), it came at a cost that have drawn criticism over the years. One of the most prominent issues is application size: even a minimal “Hello World” app can exceed 100MB because Electron bundles an entire Chromium engine and Node.js runtime within each application. This self-contained model ensures consistency across platforms but at the cost of bloated binaries, also from a backend perspective, Electron is tightly coupled to JavaScript/TypeScript and Node.js. While it’s technically possible to integrate other languages via custom native modules or local servers, doing so is complex and outside the comfort zone of most frontend teams.</p><p></p><p>Tauri’s emergence :</p><p></p><p>Because of these limitations, newer frameworks like Tauri have emerged to offer a more lightweight and flexible alternative. Tauri isn’t a browser bundled with your app — it wraps the native WebView provided by the operating system (WebKit on macOS/Linux, WebView2 on Windows), resulting in dramatically smaller binary sizes. Under the hood, Tauri uses Rust to manage communication between the frontend and backend, but it’s intentionally unopinionated about how you structure your backend logic. While Rust is the default and most integrated choice, you’re not locked into it — Tauri can communicate with any backend over a secure bridge. In our case, we’ll be using Python to implement the backend, structured like a local API the frontend can talk to, giving us access to the rich Python ecosystem while keeping the UI layer entirely web-based.</p><p></p><p>Let’s Build a To-do App</p><p></p><p>Steps :</p><p></p><p>App’s Spec</p><p></p><p>App’s architecture</p><p></p><p>App’s Setup</p><p></p><p>App’s packaging</p><p></p><p>App’s Spec :</p><p></p><p>App’s spec is very simple, a Todo List is for GUI what’s hello world is for a programming language, it’s basically an app with a GUI where you can add tasks and the added tasks get displayed, you’re also expected to be able to delete the tasks, that’s it.</p><p></p><p>App’s Architecture :</p><p></p><p>Schema :</p><p></p><p>Schema’s explanation :</p><p></p><p>Tauri is implemented in rust, thus very well integrated with it, Tauri exposes a method “invoke” that you can call from within your .vue or .js files which call a rust command which are functions decorated by #[tauri::command] containing the logic implementation, and in our case, it’s a function that calls a python api which takes the command and then either create/delete/list tasks from a local SQLite database manipulated using SQLAlchemy core</p><p></p><p>Why not using rust directly without python :</p><p></p><p>We could have, although it depends on the use case, you might be wanting to move faster than rust would allows you to, you might have a team that is not rust proficient, your app might be using some libs that are more mature in python ecosystem etc… so it depends</p><p></p><p>Technical discussion on binding Tauri — rust — python</p><p></p><p>When deciding how to make rust communicate with python, we have many solutions with pros and cons, Http protocol offers a good trade-off, let’s say a word or 2 on some solutions :</p><p></p><p>Calling python directly from rust :</p><p></p><p>Pros :</p><p></p><p>– More control remains with rust</p><p></p><p>– More control remains with rust Cons :</p><p></p><p>– hard to maintain</p><p></p><p>– overhead of python runtime starting each time you call python you have to acquire the gil and start an interpreter</p><p></p><p>Using ZeroMQ protocol :</p><p></p><p>ZeroMq protocol it what Jupyter seems to be using to make the notebook communicate with the kernel, check out this episode of developer’s voice for more info</p><p></p><p>Pros :</p><p></p><p>– High performance communication</p><p></p><p>– High performance communication Cons :</p><p></p><p>– Hard to maintain</p><p></p><p>– Non human readable</p><p></p><p>Unix domain socket :</p><p></p><p>Pros :</p><p></p><p>– High performance communication</p><p></p><p>– High performance communication Cons :</p><p></p><p>– Platform specific won’t work on Windows</p><p></p><p>Web Socket (TCP):</p><p></p><p>Pros :</p><p></p><p>– Ok performance</p><p></p><p>– Human readable</p><p></p><p>– Ok performance – Human readable Cons :</p><p></p><p>– More complex to maintain than http</p><p></p><p>Http :</p><p></p><p>Pros :</p><p></p><p>– Web friendly</p><p></p><p>– Human readable</p><p></p><p>– very maintainable for testing (you can use curl/postman)</p><p></p><p>– Web friendly – Human readable – very maintainable for testing (you can use curl/postman) Cons :</p><p></p><p>– More complex to maintain than http</p><p></p><p>So we went with http protocol, for us, it offers a good trade-off, but keep in mind, that this choice is context dependent</p><p></p><p>App’s screenshot :</p><p></p><p>This is how our little Todo app looks like</p><p></p><p>Project Setup :</p><p></p><p>Step 1 : Create a minimal Tauri project layout</p><p></p><p>#You're expected to have cargo installed https://doc.rust-lang.org/cargo/getting-started/installation.html</p><p></p><p>mkdir demo &amp;&amp; cd demo</p><p></p><p>cargo install create-tauri-app</p><p></p><p>cargo create-tauri-app</p><p></p><p># you will be answering some questions see img below</p><p></p><p># Then install node dependencies</p><p></p><p>npm install</p><p></p><p># you can display your UI with</p><p></p><p>npm run tauri dev</p><p></p><p># add a dependency we will be needing later for rust</p><p></p><p>cd src-tauri &amp;&amp; cargo add reqwest --features json</p><p></p><p>You should have a layout more and less like this one :</p><p></p><p></p><p></p><p></p><p></p><p>demo/</p><p></p><p>┣ public/</p><p></p><p>┃ ┣ tauri.svg</p><p></p><p>┃ ┗ vite.svg</p><p></p><p>┣ src/</p><p></p><p>┃ ┣ assets/</p><p></p><p>┃ ┃ ┗ vue.svg</p><p></p><p>┃ ┣ App.vue┃</p><p></p><p>┃ ┗ main.js</p><p></p><p>┣ src-tauri/</p><p></p><p>┃ ┣ capabilities/</p><p></p><p>┃ ┃ ┗ default.json</p><p></p><p>┃ ┣ src/</p><p></p><p>┃ ┃ ┣ lib.rs</p><p></p><p>┃ ┃ ┗ main.rs</p><p></p><p>┃ ┣ .gitignore</p><p></p><p>┃ ┣ Cargo.lock</p><p></p><p>┃ ┣ Cargo.toml</p><p></p><p>┃ ┣ build.rs</p><p></p><p>┃ ┗ tauri.conf.json</p><p></p><p>┣ .gitignore</p><p></p><p>┣ Makefile</p><p></p><p>┣ README.md</p><p></p><p>┣ index.html</p><p></p><p>┣ package-lock.json</p><p></p><p>┣ package.json</p><p></p><p>┗ vite.config.js</p><p></p><p>Step 2: Add python src-backend layout</p><p></p><p># since we have created the layout for the UI with tauri, now we have to do it</p><p></p><p># for the backend</p><p></p><p># You're expected to have uv the python package manager installed for the following (https://docs.astral.sh/uv/getting-started/installation/)</p><p></p><p># init a minimal python project layout</p><p></p><p>uv init --no-workspace src-backend --python 3.10</p><p></p><p>#create .venv + add dependencies</p><p></p><p>uv --directory src-backend add sqlalchemy sanic</p><p></p><p></p><p></p><p>Step 3 : Replace some files content</p><p></p><p>Let’s start with src-backend/main.py</p><p></p><p># src-backend/main.py</p><p></p><p>from sanic import Sanic</p><p></p><p>from sanic.response import json</p><p></p><p>from sqlalchemy import (</p><p></p><p>create_engine,</p><p></p><p>Table,</p><p></p><p>Column,</p><p></p><p>Integer,</p><p></p><p>String,</p><p></p><p>MetaData,</p><p></p><p>)</p><p></p><p>from sqlalchemy import insert, delete, select</p><p></p><p>from datetime import datetime</p><p></p><p># from platformdirs import user_data_dir</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p>engine = create_engine("sqlite:///./tasks.db", future=True)</p><p></p><p>metadata = MetaData()</p><p></p><p></p><p></p><p>task_table = Table(</p><p></p><p>"tasks",</p><p></p><p>metadata,</p><p></p><p>Column("id", Integer, primary_key=True),</p><p></p><p>Column("name", String, nullable=False),</p><p></p><p>Column("created_at", String), ## we keep it as a string to avoid serialization pbs for demo purposes</p><p></p><p>)</p><p></p><p></p><p></p><p>metadata.create_all(engine)</p><p></p><p></p><p></p><p>app = Sanic("TauriPythonBackend")</p><p></p><p></p><p></p><p></p><p></p><p>@app.route("/")</p><p></p><p>async def index(request):</p><p></p><p>return json({"message": "Hello world !"})</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p>@app.get("/tasks")</p><p></p><p>async def tasks_get(request):</p><p></p><p>with engine.begin() as conn:</p><p></p><p>tasks_result = [dict(el) for el in conn.execute(select(task_table)).mappings()]</p><p></p><p>return json(</p><p></p><p>{</p><p></p><p>"message": "Getting tasks for client",</p><p></p><p>"data": tasks_result,</p><p></p><p>}</p><p></p><p>)</p><p></p><p></p><p></p><p></p><p></p><p>@app.post("/tasks")</p><p></p><p>async def tasks_post(request):</p><p></p><p>data = {</p><p></p><p>"name": request.json.get("taskName", "no-name"),</p><p></p><p>"created_at": request.json.get("createdAt"),</p><p></p><p>"id": request.json.get("taskId"),</p><p></p><p>}</p><p></p><p>with engine.begin() as conn:</p><p></p><p>conn.execute(insert(task_table).values(**data))</p><p></p><p>print(f"Added task: {data['name']}")</p><p></p><p>return json({"message": f"Created task name {data.get('name')}"})</p><p></p><p></p><p></p><p>@app.delete("/tasks")</p><p></p><p>async def tasks_delete(request):</p><p></p><p>task_id = request.json.get("taskId", "no-id")</p><p></p><p>with engine.begin() as conn:</p><p></p><p>conn.execute(delete(task_table).where(task_table.c.id == task_id))</p><p></p><p>return json({"message": f"Deleted task of id {task_id}"})</p><p></p><p></p><p></p><p></p><p></p><p>if __name__ == "__main__":</p><p></p><p>app.run(host="127.0.0.1", port=8000)</p><p></p><p>Make sure you’re able to run the sanic backend :</p><p></p><p>uv run --directory src-backend sanic main:app --debug --single-process</p><p></p><p></p><p></p><p>Let’s continue with src-tauri/src/lib.rs</p><p></p><p>This implements a command able to invoke our python backend from rust with http</p><p></p><p>use reqwest::Client;</p><p></p><p>use serde_json::Value;</p><p></p><p></p><p></p><p>#[tauri::command]</p><p></p><p>async fn py_api(method: String, endpoint: String, payload: Option<value>) -&gt; Result<value, string=""> {</p><p></p><p>let client = Client::new();</p><p></p><p>let url = format!("http://127.0.0.1:8000/{}", endpoint);</p><p></p><p></p><p></p><p>let request = match method.as_str() {</p><p></p><p>"GET" =&gt; client.get(&amp;url),</p><p></p><p>"POST" =&gt; {</p><p></p><p>let req = client.post(&amp;url);</p><p></p><p>if let Some(data) = &amp;payload {</p><p></p><p>req.json(data)</p><p></p><p>} else {</p><p></p><p>req</p><p></p><p>}</p><p></p><p>}</p><p></p><p>"PUT" =&gt; client.put(&amp;url),</p><p></p><p>"DELETE" =&gt; client.delete(&amp;url),</p><p></p><p>_ =&gt; return Err(format!("Unsupported HTTP method: {}", method)),</p><p></p><p>};</p><p></p><p></p><p></p><p>let request = if let Some(data) = payload {</p><p></p><p>request.json(&amp;data)</p><p></p><p>} else {</p><p></p><p>request</p><p></p><p>};</p><p></p><p></p><p></p><p>let response = request</p><p></p><p>.send()</p><p></p><p>.await</p><p></p><p>.map_err(|e| e.to_string())?</p><p></p><p>.json::<value>()</p><p></p><p>.await</p><p></p><p>.map_err(|e| e.to_string())?;</p><p></p><p></p><p></p><p>Ok(response)</p><p></p><p>}</p><p></p><p></p><p></p><p>#[cfg_attr(mobile, tauri::mobile_entry_point)]</p><p></p><p>pub fn run() {</p><p></p><p>tauri::Builder::default()</p><p></p><p>.plugin(tauri_plugin_opener::init())</p><p></p><p>.invoke_handler(tauri::generate_handler![py_api])</p><p></p><p>.run(tauri::generate_context!())</p><p></p><p>.expect("error while running tauri application");</p><p></p><p>}</p><p></p><p>Then finally, let’s change the content of src/App.vue</p><p></p><p><script setup=""></p><p></p><p>import { ref, onMounted } from "vue";</p><p></p><p>import { invoke } from '@tauri-apps/api/core';</p><p></p><p></p><p></p><p></p><p></p><p>function callPython(method, endpoint, payload = null) {</p><p></p><p>return invoke("py_api", {</p><p></p><p>method,</p><p></p><p>endpoint,</p><p></p><p>payload,</p><p></p><p>});</p><p></p><p>}</p><p></p><p>const taskName = ref("");</p><p></p><p></p><p></p><p>const tasks = ref([]);</p><p></p><p></p><p></p><p>onMounted(async () => {</p><p></p><p>tasks.value = await callPython("GET", "tasks").then(</p><p></p><p>(response) => response.data</p><p></p><p>);</p><p></p><p>});</p><p></p><p></p><p></p><p></p><p></p><p>async function deleteTask(taskId) {</p><p></p><p>console.log("deleting task :" + `${taskId}`);</p><p></p><p>tasks.value = tasks.value.filter((task) => task.id !== taskId);</p><p></p><p>const response_data = await callPython("DELETE", "tasks", { taskId: taskId })</p><p></p><p>.then(() => {</p><p></p><p>tasks.value = tasks.value.filter((task) => task.id !== taskId);</p><p></p><p>})</p><p></p><p>.catch((error) => {</p><p></p><p>console.error("Python call failed:", error);</p><p></p><p>});</p><p></p><p>console.log(response_data);</p><p></p><p>}</p><p></p><p>async function addTask() {</p><p></p><p>const task = {</p><p></p><p>id: tasks.value.length + 1,</p><p></p><p>createdAt: new Date().toISOString(),</p><p></p><p>taskName: taskName.value,</p><p></p><p>};</p><p></p><p>const response_data = await callPython("POST", "tasks", task)</p><p></p><p>.then(() => {</p><p></p><p>tasks.value.push({ ...task, name: task.taskName });</p><p></p><p>})</p><p></p><p>.catch((error) => {</p><p></p><p>console.error("Python call failed:", error);</p><p></p><p>});</p><p></p><p>console.log(response_data);</p><p></p><p></p><p></p><p>}</p><p></p><p></script></p><p><template></p><p><main class="container"></p><p><h1>Todo list demo</h1></p><p><h2>Tauri + Vue + Python</h2></p><p><form @submit.prevent="addTask" class="row"></p><p><input id="add-task-input" placeholder="Add task name..." v-model="taskName"/></p><p><button type="submit">Add task</button></p><p></form></p><p><div class="task-list"></p><p><div :key="task.id" v-for="task in tasks"></p><p><div class="task-row"></p><p><div class="task-name"></p><p></p><p>{{ task.name }}</p><p></p><p></div></p><p><button @click="deleteTask(task.id)">Delete</button></p><p></div></p><p></div></p><p></div></p><p></main></p><p></template></p><p><style></p><p></p><p>html,</p><p></p><p>body {</p><p></p><p>height: 100%;</p><p></p><p>margin: 0;</p><p></p><p>color: #f6f6f6;</p><p></p><p>background-color: #2f2f2f;</p><p></p><p>}</p><p></p><p>#app {</p><p></p><p>display: flex;</p><p></p><p>justify-content: center;</p><p></p><p>align-items: center;</p><p></p><p>}</p><p></p><p></style></p><p><style scoped=""></p><p></p><p>.task-list {</p><p></p><p>padding: 1rem;</p><p></p><p>margin-top: 2rem;</p><p></p><p>width: 100%;</p><p></p><p>border: white dotted 1px;</p><p></p><p>border-radius: 5px;</p><p></p><p>box-shadow: #0f0f0f;</p><p></p><p>display: flex;</p><p></p><p>flex-direction: column;</p><p></p><p>gap: 1rem;</p><p></p><p>}</p><p></p><p></p><p></p><p>.task-row > button {</p><p></p><p>background: red;</p><p></p><p>padding: 0;</p><p></p><p>margin: 0;</p><p></p><p>width: 20%;</p><p></p><p>padding: 4px 0;</p><p></p><p>margin-right: 1rem;</p><p></p><p>}</p><p></p><p>.task-row > .task-name {</p><p></p><p>display: flex;</p><p></p><p>justify-content: center;</p><p></p><p>align-items: center;</p><p></p><p>/* border: #0f0f0f solid 1px; */</p><p></p><p>flex: 1;</p><p></p><p>padding: 1px;</p><p></p><p>color: black;</p><p></p><p>text-transform: uppercase;</p><p></p><p>font-size: 130%;</p><p></p><p>}</p><p></p><p>.task-row {</p><p></p><p>background: white;</p><p></p><p>padding: 4px 0;</p><p></p><p>display: flex;</p><p></p><p>border-radius: 5px;</p><p></p><p>/* justify-content: space-between; */</p><p></p><p>align-items: center;</p><p></p><p>}</p><p></p><p>.container {</p><p></p><p>padding-top: 10vh;</p><p></p><p>display: flex;</p><p></p><p>flex-direction: column;</p><p></p><p>/* justify-content: center; */</p><p></p><p>align-items: center;</p><p></p><p>height: 40vh;</p><p></p><p>/* min-height: 60vh; */</p><p></p><p>/* margin: auto; */</p><p></p><p>height: 400px;</p><p></p><p>width: 600px;</p><p></p><p>/* color: #f6f6f6;</p><p></p><p>background-color: #2f2f2f; */</p><p></p><p>margin-top: 10vh;</p><p></p><p>}</p><p></p><p>.container h1 {</p><p></p><p>font-size: 2.5em;</p><p></p><p>}</p><p></p><p></p><p></p><p>input,</p><p></p><p>button {</p><p></p><p>border-radius: 8px;</p><p></p><p>border: 1px solid transparent;</p><p></p><p>padding: 0.6em 1.2em;</p><p></p><p>font-size: 1em;</p><p></p><p>font-weight: 500;</p><p></p><p>font-family: inherit;</p><p></p><p>color: #0f0f0f;</p><p></p><p>background-color: #ffffff;</p><p></p><p>transition: border-color 0.25s;</p><p></p><p>box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);</p><p></p><p>margin-top: 2rem;</p><p></p><p>}</p><p></p><p>input {</p><p></p><p>margin-right: 1rem;</p><p></p><p>}</p><p></p><p>button {</p><p></p><p>background-color: green;</p><p></p><p>color: #ffffff;</p><p></p><p>cursor: pointer;</p><p></p><p>}</p><p></p><p></p><p></p><p>/* form {</p><p></p><p>padding: 3rem;</p><p></p><p>border: solid 1px;</p><p></p><p>} */</p><p></p><p>button:hover {</p><p></p><p>outline: solid white 1px;</p><p></p><p>box-sizing: border-box;</p><p></p><p>}</p><p></p><p>button:active {</p><p></p><p>border-color: #396cd8;</p><p></p><p>background-color: #e8e8e8;</p><p></p><p>color: black;</p><p></p><p>}</p><p></p><p></style></p><p></p><p>Step 4 : Let’s test our App and see how the front is glued to the backend</p><p></p><p># At the root of your project :</p><p></p><p>#In one terminal run the backend with the previously seen command:</p><p></p><p>uv run --directory src-backend sanic main:app --debug --single-process</p><p></p><p># In another terminal</p><p></p><p>npm run tauri dev</p><p></p><p># you will be able to add tasks to your backend in a persistant manner,</p><p></p><p># if you shut down</p><p></p><p>Now that we have successfully built a To-do List app using Tauri + Vue + Python, let’s see how we can package it</p><p></p><p>Packaging your app for production :</p><p></p><p>This section has caused me some pain to make the code work, but it was worth it. To make our app packageable and production ready, we should :</p><p></p><p>Bundle the python code to an exec binary (we will use pyinstaller)</p><p></p><p>Add this binary location to tauri’s config</p><p></p><p>Add some code logic to spawn the backend binary at startup time, and shut it down when the GUI exits</p><p></p><p>Build your app and generate a final binary desktop app</p><p></p><p>Bundle python code with pyinstaller :</p><p></p><p>Pyinstaller allows us to “compile” python to an exec, that can be executed without a python interpreter.</p><p></p><p># we should install pyinstaller as a dev dependency</p><p></p><p># At the root folder, run :</p><p></p><p>uv --directory src-backend add pyinstaller --group dev</p><p></p><p># once pyinstaller installed, at the root folder run :</p><p></p><p>uv --directory src-backend run pyinstaller run.py \</p><p></p><p>--onefile \</p><p></p><p>--name python_backend \</p><p></p><p>--clean \</p><p></p><p>--log-level=DEBUG \</p><p></p><p>--collect-all sqlalchemy \</p><p></p><p>--collect-all sanic \</p><p></p><p>--collect-all sanic_routing \</p><p></p><p>--collect-all tracerite</p><p></p><p>You should then have generated a “src-backend/dist/python_backend” that you can run as such “./src-backend/dist/python_backend” :</p><p></p><p>Add the binary to tauri’s config :</p><p></p><p>1st, consider creating a folder src-tauri/binaries that will hold all the binaries your app might rely on.</p><p></p><p>Then copy the generated binary like this :</p><p></p><p>cp src-backend/dist/python_backend src-tauri/binaries/python_backend-$(rustc -vV | grep host | awk '{print $2}')</p><p></p><p>Notice that we’re adding ${rustc -vV | grep host | awk ‘{print $2}’} in my case it’s gonna be mapped to this path src-tauri/binaries/python_backend-aarch64-apple-darwin , Tauri expec the platform-specific triple (-aarch64-apple-darwin in my case) to be have cross-platform compilation but in tauri.conf.json, no need to add this suffix, just add the entry :</p><p></p><p>{ "bundle" :</p><p></p><p>{</p><p></p><p>"externalBin": [</p><p></p><p>"binaries/python_backend"</p><p></p><p>]</p><p></p><p>}</p><p></p><p>}</p><p></p><p>Once done, Tauri would be able to include the python binary in it final binary, but it doesn’t mean that it will be able to launch it, this what we will see in the next step</p><p></p><p>Spawn and shut down the backend with startup and app’s shutdown :</p><p></p><p>To have this bheaviour where it is Tauri that handle the lifecycle of the python_backend, we have to make some modification on our rust files, 1st, let’s create a src-tauri/src/api.rs that will hold the py_api cmd implementation. :</p><p></p><p># src-tauri/src/api.rs</p><p></p><p>use reqwest::Client;</p><p></p><p>use serde_json::Value;</p><p></p><p></p><p></p><p>#[tauri::command]</p><p></p><p>pub async fn py_api(</p><p></p><p>method: String,</p><p></p><p>endpoint: String,</p><p></p><p>payload: Option<value>,</p><p></p><p>) -&gt; Result<value, string=""> {</p><p></p><p>let client = Client::new();</p><p></p><p>let url = format!("http://127.0.0.1:8000/{}", endpoint);</p><p></p><p></p><p></p><p>let request = match method.as_str() {</p><p></p><p>"GET" =&gt; client.get(&amp;url),</p><p></p><p>"POST" =&gt; {</p><p></p><p>let req = client.post(&amp;url);</p><p></p><p>if let Some(data) = &amp;payload {</p><p></p><p>req.json(data)</p><p></p><p>} else {</p><p></p><p>req</p><p></p><p>}</p><p></p><p>}</p><p></p><p>"PUT" =&gt; client.put(&amp;url),</p><p></p><p>"DELETE" =&gt; client.delete(&amp;url),</p><p></p><p>_ =&gt; return Err(format!("Unsupported HTTP method: {}", method)),</p><p></p><p>};</p><p></p><p></p><p></p><p>let request = if let Some(data) = payload {</p><p></p><p>request.json(&amp;data)</p><p></p><p>} else {</p><p></p><p>request</p><p></p><p>};</p><p></p><p></p><p></p><p>let response = request</p><p></p><p>.send()</p><p></p><p>.await</p><p></p><p>.map_err(|e| e.to_string())?</p><p></p><p>.json::<value>()</p><p></p><p>.await</p><p></p><p>.map_err(|e| e.to_string())?;</p><p></p><p></p><p></p><p>Ok(response)</p><p></p><p>}</p><p></p><p>Then src-tauri/src/lib.rs will just expose py_api to other modules :</p><p></p><p>//! src-tauri/src/lib.rs</p><p></p><p>pub mod api; // brings the module in</p><p></p><p></p><p></p><p>// Re-export the command to make it available to main.rs</p><p></p><p>pub use api::py_api;</p><p></p><p>Then it’s src-tauri/src/main.rs that will contain the logic to start tauri and handle the backend lifecycle :</p><p></p><p>//! src-tauri/src/main.rs</p><p></p><p>#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]</p><p></p><p></p><p></p><p>use std::{</p><p></p><p>env,</p><p></p><p>io::{BufRead, BufReader},</p><p></p><p>process::{Child, Command, Stdio},</p><p></p><p>sync::{Arc, Mutex},</p><p></p><p>thread,</p><p></p><p>};</p><p></p><p>use tauri::RunEvent;</p><p></p><p></p><p></p><p>/// “python_backend.exe” on Windows, “python_backend” elsewhere.</p><p></p><p>fn backend_filename() -&gt; &amp;'static str {</p><p></p><p>if cfg!(windows) {</p><p></p><p>"python_backend.exe"</p><p></p><p>} else {</p><p></p><p>"python_backend"</p><p></p><p>}</p><p></p><p>}</p><p></p><p></p><p></p><p>/// Spawns the side-car in the same folder as this executable.</p><p></p><p>fn spawn_backend() -&gt; std::io::Result<child> {</p><p></p><p>// Locate the Tauri executable, then its parent folder</p><p></p><p>let exe_path = env::current_exe().expect("failed to get current exe path");</p><p></p><p>let exe_dir = exe_path</p><p></p><p>.parent()</p><p></p><p>.expect("failed to get parent directory of exe");</p><p></p><p></p><p></p><p>// Build the full path to python_backend[-<triple>].exe</p><p></p><p>// Tauri build will have renamed the suffixed file to plain name next to the exe.</p><p></p><p>let backend_path = exe_dir.join(backend_filename());</p><p></p><p></p><p></p><p>println!("▶ looking for side-car at {:?}", backend_path);</p><p></p><p>let mut child = Command::new(&amp;backend_path)</p><p></p><p>.stdout(Stdio::piped())</p><p></p><p>.stderr(Stdio::piped())</p><p></p><p>.spawn()?;</p><p></p><p></p><p></p><p>// Pipe stdout</p><p></p><p>if let Some(out) = child.stdout.take() {</p><p></p><p>thread::spawn(move || {</p><p></p><p>for line in BufReader::new(out).lines().flatten() {</p><p></p><p>println!("[backend] {line}");</p><p></p><p>}</p><p></p><p>});</p><p></p><p>}</p><p></p><p>// Pipe stderr</p><p></p><p>if let Some(err) = child.stderr.take() {</p><p></p><p>thread::spawn(move || {</p><p></p><p>for line in BufReader::new(err).lines().flatten() {</p><p></p><p>eprintln!("[backend-err] {line}");</p><p></p><p>}</p><p></p><p>});</p><p></p><p>}</p><p></p><p></p><p></p><p>println!("▶ spawned backend: {:?}", backend_path);</p><p></p><p>Ok(child)</p><p></p><p>}</p><p></p><p></p><p></p><p>fn main() {</p><p></p><p>// Shared handle so we can kill it on exit</p><p></p><p>let child_handle = Arc::new(Mutex::new(None));</p><p></p><p></p><p></p><p>// Build the app</p><p></p><p>let app = tauri::Builder::default()</p><p></p><p>.setup({</p><p></p><p>let child_handle = child_handle.clone();</p><p></p><p>move |_app_handle| {</p><p></p><p>let child = spawn_backend().expect("failed to spawn python backend");</p><p></p><p>*child_handle.lock().unwrap() = Some(child);</p><p></p><p>Ok(())</p><p></p><p>}</p><p></p><p>})</p><p></p><p>.invoke_handler(tauri::generate_handler![demo_todo_ru_py_lib::py_api])</p><p></p><p>.build(tauri::generate_context!())</p><p></p><p>.expect("error building Tauri");</p><p></p><p></p><p></p><p>// Run and on Exit make sure to kill the backend</p><p></p><p>let exit_handle = child_handle.clone();</p><p></p><p>app.run(move |_app_handle, event| {</p><p></p><p>if let RunEvent::Exit = event {</p><p></p><p>if let Some(mut child) = exit_handle.lock().unwrap().take() {</p><p></p><p>let _ = child.kill();</p><p></p><p>println!("⛔ backend terminated");</p><p></p><p>}</p><p></p><p>}</p><p></p><p>});</p><p></p><p>}</p><p></p><p>Once you have all of that in place, you can finally, build your app to a binary desktop application</p><p></p><p>Build your app and generate a final binary desktop app :</p><p></p><p>Finally the final step :</p><p></p><p># At the root of the folder run :</p><p></p><p>cd src-tauri &amp;&amp; npm run tauri build</p><p></p><p>If all the previous steps went good, you should optain a binary “src-tauri/target/release/bundle/dmg/demo-todo-ru-py_0.1.0_aarch64.dmg”</p><p></p><p>For mac OS just run the cmd :</p><p></p><p>open ./src-tauri/target/release/bundle/dmg/demo-todo-ru-py_0.1.0_aarch64.dmg</p><p></p><p>And you will have a screen like that and then you can use your app as any other one</p><p></p><p>Conclusion :</p><p></p><p>That’s it we’re finally at the end, it was dense, but i think it worths it, it’s a pattern that might be very useful in some context where you don’ want to use Tkinter, or your team already deeply invested in python ecosystem and web technologies.</p><p></p><p>You can get the final repo of the project here it’s slightly different than the code shown here to bring some robustness</p><p></p><p>Reference :</triple></child></value></value,></value></value></value,></value>
    </div>
</body>
</html>
